%% Analyze correlation in decoded time between cluster 1 and cluster 2
%  Only analyze sessions w/ good cluster 1 and cluster 2 decoding (20+ cells) 

paths = struct;
paths.nb_results = './structs/nb_results14_Mar_2021.mat';
load(paths.nb_results); 
paths.neuro_data = '/Users/joshstern/Documents/UchidaLab_NeuralData/processed_neuropix_data/all_mice';
% close all
paths.beh_data = '/Users/joshstern/Dropbox (Uchida Lab)/patchforaging_behavior/processed_data';
% add behavioral data path
addpath(genpath('/Users/joshstern/Dropbox (Uchida Lab)/patchforaging_behavior/processed_data'));

paths.sig_cells = '/Users/joshstern/Documents/UchidaLab_NeuralData/processed_neuropix_data/glm_results/gmm/sig_cells_table_gmm_mb_cohort_PFC.mat';
load(paths.sig_cells);  

sessions = dir(fullfile(paths.beh_data,'*.mat'));
sessions = {sessions.name};  

% to pare down to just recording sessions
recording_sessions = dir(fullfile(paths.neuro_data,'*.mat'));
recording_sessions = {recording_sessions.name};
% to just use recording sessions
recording_session_bool = cellfun(@(x) ismember(x,recording_sessions),sessions);
sessions = sessions(recording_session_bool);
tbin_ms = .02 * 1000;

mouse_grps = {1:2,3:8,10:13,14:18,[23 25]}; 
pool_sessions = nb_results.clu12_pool_sessions; % only use good clu1 and clu2 sessions
analysis_mice = find(~cellfun(@isempty ,pool_sessions));
analysis_sessions = arrayfun(@(i_mouse) mouse_grps{i_mouse}(nb_results.pool_sessions{i_mouse}),1:length(mouse_grps),'un',0);
mouse_names = ["m75","m76","m78","m79","m80"];
session_titles = cell(numel(analysis_sessions),1);
for mIdx = 1:numel(analysis_sessions)
    for i = 1:numel(analysis_sessions{mIdx})
        sIdx = analysis_sessions{mIdx}(i);
        session_title = ['m' sessions{sIdx}(1:2) ' ' sessions{sIdx}(end-6) '/' sessions{sIdx}(end-5:end-4)];
        session_titles{mIdx}{i} = session_title;
    end
end  

feature_names = cellfun(@(x) x.name, nb_results.dataset_opt.features{5}{1});
var_dt = diff(nb_results.var_bins{1}{1}{1}(1:2));

%% Load decoded time since and time on patch from 

y_hat = nb_results.y_hat;
nMice = numel(analysis_sessions); 

timeSince_hat = cell(nMice,1); 
timePatch_hat = cell(nMice,1); 

% to load from decoding directly
timeSince_ix = 1; 
timePatch_ix = 2; 

% these are just from the pop_decoding_session_sep
rewsizes = [1 2 4];
rewsize = cell(nMice,1); 
RXNil = cell(nMice,1); 
prts = cell(nMice,1); 
postRew_prts = cell(nMice,1); 
last_rew_ix = cell(nMice,1); 

% choose which features to reformat for analysis
trial_decoding_features = 1:6;

n_cells = cell(nMice,1); 

for mIdx = 1:numel(analysis_sessions)
    for i_i = 1:numel(analysis_sessions{mIdx})
        i = analysis_sessions{mIdx}(i_i); 
        within_mouse_ix = nb_results.pool_sessions{mIdx}(i_i); % session within mouse mPFC sessions
        sIdx = analysis_sessions{mIdx}(i_i);  
        session = sessions{sIdx}(1:end-4); 
        
        data = load(fullfile(paths.beh_data,sessions{sIdx}));  
        session_title = session([1:2 end-2:end]);
        session_rewsize = mod(data.patches(:,2),10); 
        patchstop_sec = data.patchCSL(:,2);
        patchleave_sec = data.patchCSL(:,3);   
        rew_sec = data.rew_ts;
        session_prts = patchleave_sec - patchstop_sec;  
        nTrials = length(session_rewsize);
        
        % Make RXNil vector
        session_RXNil = nan(nTrials,1); 
        last_rew_sec = nan(nTrials,1); 
        i_last_rew_ix = nan(nTrials,1); 
        for iTrial = 1:nTrials
            rew_indices = round(rew_sec(rew_sec >= patchstop_sec(iTrial) & rew_sec < patchleave_sec(iTrial)) - patchstop_sec(iTrial)) + 1;
            if session_prts(iTrial) >= 1 % only care if we have at least 1 second on patch
                if isequal(rew_indices,1)
                    session_RXNil(iTrial) = 10*session_rewsize(iTrial);
                elseif isequal(rew_indices,[1 ; 2])
                    session_RXNil(iTrial) = 10*session_rewsize(iTrial) + session_rewsize(iTrial);
                end
            end
            last_rew_sec(iTrial) = rew_indices(end);
            i_last_rew_ix(iTrial) = round(((rew_indices(end)-1) * 1000) / tbin_ms);
        end
        session_postRew_prts = session_prts - last_rew_sec; 
        i_last_rew_ix(i_last_rew_ix == 0) = 1; 
    
        % reformat decoded time
        for i_feature = 1:numel(trial_decoding_features)
            iFeature = trial_decoding_features(i_feature);
            timeSince_hat{mIdx}{i_i}{i_feature} = arrayfun(@(iTrial) y_hat{mIdx}{within_mouse_ix}{iTrial}{timeSince_ix}{min(3,session_rewsize(iTrial))}{iFeature},(1:nTrials)','un',0);
            timePatch_hat{mIdx}{i_i}{i_feature} = arrayfun(@(iTrial) y_hat{mIdx}{within_mouse_ix}{iTrial}{timePatch_ix}{min(3,session_rewsize(iTrial))}{iFeature},(1:nTrials)','un',0);
        end
        
        % get number of cells per cluster
        session_sigcells = sig_cells(strcmp(sig_cells.Session,session),:); 
        glm_clusters_session = session_sigcells.GMM_cluster; 
        n_cells{mIdx}{i_i} = [arrayfun(@(x) length(find(glm_clusters_session == x)),(1:4)) length(glm_clusters_session)];
        
        % log trial/behavior information
        rewsize{mIdx}{i_i} = session_rewsize;
        RXNil{mIdx}{i_i} = session_RXNil; 
        prts{mIdx}{i_i} = session_prts; 
        postRew_prts{mIdx}{i_i} = session_postRew_prts; 
        last_rew_ix{mIdx}{i_i} = i_last_rew_ix;
    end
end 
clear y_hat % we now have this in an easier form to work with